/*******************************************************************************
 * Copyright (c) 2022, Jan Koester jan.koester@gmx.net
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 * Neither the name of the <organization> nor the
 *      names of its contributors may be used to endorse or promote products
 *      derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *******************************************************************************/

#include "iosfwd"
#include "type_traits"

#pragma once

namespace std {
  template<class CharT, class Traits = char_traits<CharT>>
  class basic_istream : virtual public basic_ios<CharT, Traits> {
  public:
    // types (inherited from basic_ios)
    using char_type   = CharT;
    using int_type    = typename Traits::int_type;
    using pos_type    = typename Traits::pos_type;
    using off_type    = typename Traits::off_type;
    using traits_type = Traits;
 
    // constructor/destructor
    explicit basic_istream(basic_streambuf<CharT, Traits>* sb);
    virtual ~basic_istream();
 
    // prefix/suffix
    class sentry;
 
    // formatted input
    basic_istream<CharT, Traits>&
      operator>>(basic_istream<CharT, Traits>& (*pf)(basic_istream<CharT, Traits>&));
    basic_istream<CharT, Traits>&
      operator>>(basic_ios<CharT, Traits>& (*pf)(basic_ios<CharT, Traits>&));
    basic_istream<CharT, Traits>&
      operator>>(ios_base& (*pf)(ios_base&));
 
    basic_istream<CharT, Traits>& operator>>(bool& n);
    basic_istream<CharT, Traits>& operator>>(short& n);
    basic_istream<CharT, Traits>& operator>>(unsigned short& n);
    basic_istream<CharT, Traits>& operator>>(int& n);
    basic_istream<CharT, Traits>& operator>>(unsigned int& n);
    basic_istream<CharT, Traits>& operator>>(long& n);
    basic_istream<CharT, Traits>& operator>>(unsigned long& n);
    basic_istream<CharT, Traits>& operator>>(long long& n);
    basic_istream<CharT, Traits>& operator>>(unsigned long long& n);
    basic_istream<CharT, Traits>& operator>>(float& f);
    basic_istream<CharT, Traits>& operator>>(double& f);
    basic_istream<CharT, Traits>& operator>>(long double& f);
 
    basic_istream<CharT, Traits>& operator>>(void*& p);
    basic_istream<CharT, Traits>& operator>>(basic_streambuf<char_type, Traits>* sb);
 
    // unformatted input
    streamsize gcount() const;
    int_type get();
    basic_istream<CharT, Traits>& get(char_type& c);
    basic_istream<CharT, Traits>& get(char_type* s, streamsize n);
    basic_istream<CharT, Traits>& get(char_type* s, streamsize n, char_type delim);
    basic_istream<CharT, Traits>& get(basic_streambuf<char_type, Traits>& sb);
    basic_istream<CharT, Traits>&
      get(basic_streambuf<char_type, Traits>& sb, char_type delim);
 
    basic_istream<CharT, Traits>& getline(char_type* s, streamsize n);
    basic_istream<CharT, Traits>& getline(char_type* s, streamsize n, char_type delim);
 
    basic_istream<CharT, Traits>& ignore(streamsize n = 1, int_type delim = Traits::eof());
    int_type                      peek();
    basic_istream<CharT, Traits>& read    (char_type* s, streamsize n);
    streamsize                    readsome(char_type* s, streamsize n);
 
    basic_istream<CharT, Traits>& putback(char_type c);
    basic_istream<CharT, Traits>& unget();
    int sync();
 
    pos_type tellg();
    basic_istream<CharT, Traits>& seekg(pos_type);
    basic_istream<CharT, Traits>& seekg(off_type, ios_base::seekdir);
 
  protected:
    // copy/move constructor
    basic_istream(const basic_istream&) = delete;
    basic_istream(basic_istream&& rhs);
 
    // assign and swap
    basic_istream& operator=(const basic_istream&) = delete;
    basic_istream& operator=(basic_istream&& rhs);
    void swap(basic_istream& rhs);
  };
 
  // character extraction templates
  template<class CharT, class Traits>
    basic_istream<CharT, Traits>& operator>>(basic_istream<CharT, Traits>&, CharT&);
  template<class Traits>
    basic_istream<char, Traits>& operator>>(basic_istream<char, Traits>&, unsigned char&);
  template<class Traits>
    basic_istream<char, Traits>& operator>>(basic_istream<char, Traits>&, signed char&);
 
  template<class CharT, class Traits, size_t N>
    basic_istream<CharT, Traits>&
      operator>>(basic_istream<CharT, Traits>&, CharT(&)[N]);
  template<class Traits, size_t N>
    basic_istream<char, Traits>&
      operator>>(basic_istream<char, Traits>&, unsigned char(&)[N]);
  template<class Traits, size_t N>
    basic_istream<char, Traits>&
      operator>>(basic_istream<char, Traits>&, signed char(&)[N]);
}

namespace std {
  template<class CharT, class Traits = char_traits<CharT>>
  class basic_istream<CharT, Traits>::sentry {
    bool ok_;                   // exposition only
  public:
    explicit sentry(basic_istream<CharT, Traits>& is, bool noskipws = false);
    ~sentry();
    explicit operator bool() const { return ok_; }
    sentry(const sentry&) = delete;
    sentry& operator=(const sentry&) = delete;
  };
}

namespace std {
  template<class CharT, class Traits = char_traits<CharT>>
  class basic_iostream
    : public basic_istream<CharT, Traits>,
      public basic_ostream<CharT, Traits> {
  public:
    using char_type   = CharT;
    using int_type    = typename Traits::int_type;
    using pos_type    = typename Traits::pos_type;
    using off_type    = typename Traits::off_type;
    using traits_type = Traits;
 
    // constructor
    explicit basic_iostream(basic_streambuf<CharT, Traits>* sb);
 
    // destructor
    virtual ~basic_iostream();
 
  protected:
    // constructor
    basic_iostream(const basic_iostream&) = delete;
    basic_iostream(basic_iostream&& rhs);
 
    // assign and swap
    basic_iostream& operator=(const basic_iostream&) = delete;
    basic_iostream& operator=(basic_iostream&& rhs);
    void swap(basic_iostream& rhs);
  };
}
