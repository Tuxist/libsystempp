/*******************************************************************************
Copyright (c) 2022, Jan Koester jan.koester@gmx.net
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the <organization> nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*******************************************************************************/

#include <type_traits>

#pragma once

enum class __attribute__((__visibility__("default"))) _OrdResult : signed char {
  __less = -1,
  __equiv = 0,
  __greater = 1
};

enum class __attribute__((__visibility__("default"))) _NCmpResult : signed char {
  __unordered = -127
};

namespace std {
class partial_ordering;
class weak_ordering;
class strong_ordering;

template<class _Tp, class... _Args>
inline constexpr bool __one_of_v = (is_same_v<_Tp, _Args> || ...);

struct _CmpUnspecifiedParam {
  __attribute__ ((visibility ("hidden"))) consteval
  _CmpUnspecifiedParam(int _CmpUnspecifiedParam::*) noexcept {}

  template<class _Tp, class = enable_if_t<!__one_of_v<_Tp, int, partial_ordering, weak_ordering, strong_ordering>>>
  _CmpUnspecifiedParam(_Tp) = delete;
};

class partial_ordering {
  using _ValueT = signed char;

  __attribute__ ((visibility ("hidden")))
  explicit constexpr partial_ordering(_OrdResult __v) noexcept
      : __value_(_ValueT(__v)) {}

  __attribute__ ((visibility ("hidden")))
  explicit constexpr partial_ordering(_NCmpResult __v) noexcept
      : __value_(_ValueT(__v)) {}

  __attribute__ ((visibility ("hidden")))
  constexpr bool __is_ordered() const noexcept {
    return __value_ != _ValueT(_NCmpResult::__unordered);
  }
public:
  // valid values
  static const partial_ordering less;
  static const partial_ordering equivalent;
  static const partial_ordering greater;
  static const partial_ordering unordered;

  // comparisons
  __attribute__ ((visibility ("hidden")))
  friend constexpr bool operator==(partial_ordering, partial_ordering) noexcept = default;

  __attribute__ ((visibility ("hidden")))
  friend constexpr bool operator==(partial_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__is_ordered() && __v.__value_ == 0;
  }

  __attribute__ ((visibility ("hidden")))
  friend constexpr bool operator< (partial_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__is_ordered() && __v.__value_ < 0;
  }

  __attribute__ ((visibility ("hidden")))
  friend constexpr bool operator<=(partial_ordering __v, _CmpUnspecifiedParam) noexcept  {
    return __v.__is_ordered() && __v.__value_ <= 0;
  }

  __attribute__ ((visibility ("hidden")))
  friend constexpr bool operator> (partial_ordering __v, _CmpUnspecifiedParam) noexcept  {
    return __v.__is_ordered() && __v.__value_ > 0;
  }

  __attribute__ ((visibility ("hidden")))
  friend constexpr bool operator>=(partial_ordering __v, _CmpUnspecifiedParam) noexcept  {
    return __v.__is_ordered() && __v.__value_ >= 0;
  }

  __attribute__ ((visibility ("hidden")))
  friend constexpr bool operator< (_CmpUnspecifiedParam, partial_ordering __v) noexcept  {
    return __v.__is_ordered() && 0 < __v.__value_;
  }

  __attribute__ ((visibility ("hidden")))
  friend constexpr bool operator<=(_CmpUnspecifiedParam, partial_ordering __v) noexcept  {
    return __v.__is_ordered() && 0 <= __v.__value_;
  }

  __attribute__ ((visibility ("hidden")))
  friend constexpr bool operator> (_CmpUnspecifiedParam, partial_ordering __v) noexcept  {
    return __v.__is_ordered() && 0 > __v.__value_;
  }

  __attribute__ ((visibility ("hidden")))
  friend constexpr bool operator>=(_CmpUnspecifiedParam, partial_ordering __v) noexcept  {
    return __v.__is_ordered() && 0 >= __v.__value_;
  }

  __attribute__ ((visibility ("hidden")))
  friend constexpr partial_ordering operator<=>(partial_ordering __v, _CmpUnspecifiedParam) noexcept  {
    return __v;
  }

  __attribute__ ((visibility ("hidden")))
  friend constexpr partial_ordering operator<=>(_CmpUnspecifiedParam, partial_ordering __v) noexcept  {
    return __v < 0 ? partial_ordering::greater : (__v > 0 ? partial_ordering::less : __v);
  }
private:
  _ValueT __value_;
};

inline constexpr partial_ordering partial_ordering::less(_OrdResult::__less);
inline constexpr partial_ordering partial_ordering::equivalent(_OrdResult::__equiv);
inline constexpr partial_ordering partial_ordering::greater(_OrdResult::__greater);
inline constexpr partial_ordering partial_ordering::unordered(_NCmpResult ::__unordered);

class weak_ordering {
  using _ValueT = signed char;

  __attribute__ ((visibility ("hidden")))
  explicit constexpr weak_ordering(_OrdResult __v) noexcept : __value_(_ValueT(__v)) {}

public:
  static const weak_ordering less;
  static const weak_ordering equivalent;
  static const weak_ordering greater;

  __attribute__ ((visibility ("hidden")))
  constexpr operator partial_ordering() const noexcept {
    return __value_ == 0 ? partial_ordering::equivalent
        : (__value_ < 0 ? partial_ordering::less : partial_ordering::greater);
  }

  // comparisons
  __attribute__ ((visibility ("hidden")))
  friend constexpr bool operator==(weak_ordering, weak_ordering) noexcept = default;

  __attribute__ ((visibility ("hidden")))
  friend constexpr bool operator==(weak_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ == 0;
  }

  __attribute__ ((visibility ("hidden")))
  friend constexpr bool operator< (weak_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ < 0;
  }

  __attribute__ ((visibility ("hidden")))
  friend constexpr bool operator<=(weak_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ <= 0;
  }

  __attribute__ ((visibility ("hidden")))
  friend constexpr bool operator> (weak_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ > 0;
  }

  __attribute__ ((visibility ("hidden")))
  friend constexpr bool operator>=(weak_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ >= 0;
  }

  __attribute__ ((visibility ("hidden")))
  friend constexpr bool operator< (_CmpUnspecifiedParam, weak_ordering __v) noexcept {
    return 0 < __v.__value_;
  }

  __attribute__ ((visibility ("hidden")))
  friend constexpr bool operator<=(_CmpUnspecifiedParam, weak_ordering __v) noexcept {
    return 0 <= __v.__value_;
  }

  __attribute__ ((visibility ("hidden")))
  friend constexpr bool operator> (_CmpUnspecifiedParam, weak_ordering __v) noexcept {
    return 0 > __v.__value_;
  }

  __attribute__ ((visibility ("hidden")))
  friend constexpr bool operator>=(_CmpUnspecifiedParam, weak_ordering __v) noexcept {
    return 0 >= __v.__value_;
  }

  __attribute__ ((visibility ("hidden")))
  friend constexpr weak_ordering operator<=>(weak_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v;
  }

  __attribute__ ((visibility ("hidden")))
  friend constexpr weak_ordering operator<=>(_CmpUnspecifiedParam, weak_ordering __v) noexcept {
    return __v < 0 ? weak_ordering::greater : (__v > 0 ? weak_ordering::less : __v);
  }

private:
  _ValueT __value_;
};

inline constexpr weak_ordering weak_ordering::less(_OrdResult::__less);
inline constexpr weak_ordering weak_ordering::equivalent(_OrdResult::__equiv);
inline constexpr weak_ordering weak_ordering::greater(_OrdResult::__greater);

class strong_ordering {
  using _ValueT = signed char;

  __attribute__ ((visibility ("hidden")))
  explicit constexpr strong_ordering(_OrdResult __v) noexcept : __value_(_ValueT(__v)) {}

public:
  static const strong_ordering less;
  static const strong_ordering equal;
  static const strong_ordering equivalent;
  static const strong_ordering greater;

  // conversions
  __attribute__ ((visibility ("hidden")))
  constexpr operator partial_ordering() const noexcept {
    return __value_ == 0 ? partial_ordering::equivalent
        : (__value_ < 0 ? partial_ordering::less : partial_ordering::greater);
  }

  __attribute__ ((visibility ("hidden")))
  constexpr operator weak_ordering() const noexcept {
    return __value_ == 0 ? weak_ordering::equivalent
        : (__value_ < 0 ? weak_ordering::less : weak_ordering::greater);
  }

  // comparisons
  __attribute__ ((visibility ("hidden")))
  friend constexpr bool operator==(strong_ordering, strong_ordering) noexcept = default;

  __attribute__ ((visibility ("hidden")))
  friend constexpr bool operator==(strong_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ == 0;
  }

  __attribute__ ((visibility ("hidden")))
  friend constexpr bool operator< (strong_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ < 0;
  }

  __attribute__ ((visibility ("hidden")))
  friend constexpr bool operator<=(strong_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ <= 0;
  }

  __attribute__ ((visibility ("hidden")))
  friend constexpr bool operator> (strong_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ > 0;
  }

  __attribute__ ((visibility ("hidden")))
  friend constexpr bool operator>=(strong_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ >= 0;
  }

  __attribute__ ((visibility ("hidden")))
  friend constexpr bool operator< (_CmpUnspecifiedParam, strong_ordering __v) noexcept {
    return 0 < __v.__value_;
  }

  __attribute__ ((visibility ("hidden")))
  friend constexpr bool operator<=(_CmpUnspecifiedParam, strong_ordering __v) noexcept {
    return 0 <= __v.__value_;
  }

  __attribute__ ((visibility ("hidden")))
  friend constexpr bool operator> (_CmpUnspecifiedParam, strong_ordering __v) noexcept {
    return 0 > __v.__value_;
  }

  __attribute__ ((visibility ("hidden")))
  friend constexpr bool operator>=(_CmpUnspecifiedParam, strong_ordering __v) noexcept {
    return 0 >= __v.__value_;
  }

  __attribute__ ((visibility ("hidden")))
  friend constexpr strong_ordering operator<=>(strong_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v;
  }

  __attribute__ ((visibility ("hidden")))
  friend constexpr strong_ordering operator<=>(_CmpUnspecifiedParam, strong_ordering __v) noexcept {
    return __v < 0 ? strong_ordering::greater : (__v > 0 ? strong_ordering::less : __v);
  }

private:
  _ValueT __value_;
};

inline constexpr strong_ordering strong_ordering::less(_OrdResult::__less);
inline constexpr strong_ordering strong_ordering::equal(_OrdResult::__equiv);
inline constexpr strong_ordering strong_ordering::equivalent(_OrdResult::__equiv);
inline constexpr strong_ordering strong_ordering::greater(_OrdResult::__greater);

namespace __compare_detail {

enum _ClassifyCompCategory : unsigned {
  _None,
  _PartialOrd,
  _WeakOrd,
  _StrongOrd,
  _CCC_Size
};

template <class _Tp>
__attribute__ ((visibility ("hidden")))
constexpr _ClassifyCompCategory __type_to_enum() noexcept {
  if (is_same_v<_Tp, partial_ordering>)
    return _PartialOrd;
  if (is_same_v<_Tp, weak_ordering>)
    return _WeakOrd;
  if (is_same_v<_Tp, strong_ordering>)
    return _StrongOrd;
  return _None;
}

template <size_t _Size>
__attribute__ ((visibility ("hidden")))
constexpr _ClassifyCompCategory
__compute_comp_type(const _ClassifyCompCategory (&__types)[_Size]) {
  int __seen[_CCC_Size] = {};
  for (auto __type : __types)
    ++__seen[__type];
  if (__seen[_None])
    return _None;
  if (__seen[_PartialOrd])
    return _PartialOrd;
  if (__seen[_WeakOrd])
    return _WeakOrd;
  return _StrongOrd;
}

template <class ..._Ts, bool _False = false>
__attribute__ ((visibility ("hidden")))
constexpr auto __get_comp_type() {
  using _CCC = _ClassifyCompCategory;
  constexpr _CCC __type_kinds[] = {_StrongOrd, __type_to_enum<_Ts>()...};
  constexpr _CCC _Cat = __compute_comp_type(__type_kinds);
  if constexpr (_Cat == _None)
    return void();
  else if constexpr (_Cat == _PartialOrd)
    return partial_ordering::equivalent;
  else if constexpr (_Cat == _WeakOrd)
    return weak_ordering::equivalent;
  else if constexpr (_Cat == _StrongOrd)
    return strong_ordering::equivalent;
  else
    static_assert(_False, "unhandled case");
}
}

template<class... _Ts>
struct __attribute__((__visibility__("default"))) common_comparison_category {
  using type = decltype(__compare_detail::__get_comp_type<_Ts...>());
};

template<class... _Ts>
using common_comparison_category_t = typename common_comparison_category<_Ts...>::type;
};

namespace std {
    template<class, class, class>
    struct __attribute__ ((visibility ("hidden"))) __compare_three_way_result { };

    template<class _Tp, class _Up>
    struct __attribute__ ((visibility ("hidden"))) __compare_three_way_result<_Tp, _Up, decltype(
        declval<__make_const_lvalue_ref<_Tp>>() <=> declval<__make_const_lvalue_ref<_Up>>(), void()
    )> {
        using type = decltype(declval<__make_const_lvalue_ref<_Tp>>() <=> declval<__make_const_lvalue_ref<_Up>>());
    };

    template<class _Tp, class _Up = _Tp>
    struct __attribute__((__visibility__("default"))) compare_three_way_result : __compare_three_way_result<_Tp, _Up, void> { };

    template<class _Tp, class _Up = _Tp>
    using compare_three_way_result_t = typename compare_three_way_result<_Tp, _Up>::type;
}
