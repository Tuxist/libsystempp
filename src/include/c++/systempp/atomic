/*******************************************************************************
Copyright (c) 2021, Jan Koester jan.koester@gmx.net
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the <organization> nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*******************************************************************************/

#include <cstdint>
#include <cstddef>

#pragma once

namespace std {
  enum class memory_order : unsigned int {
    relaxed = 0,
    consume = 1, 
    acquire = 2,
    release = 4, 
    acq_rel = 6,
    seq_cst = 14
  };
  
  inline constexpr memory_order memory_order_relaxed = memory_order::relaxed;
  inline constexpr memory_order memory_order_consume = memory_order::consume;
  inline constexpr memory_order memory_order_acquire = memory_order::acquire;
  inline constexpr memory_order memory_order_release = memory_order::release;
  inline constexpr memory_order memory_order_acq_rel = memory_order::acq_rel;
  inline constexpr memory_order memory_order_seq_cst = memory_order::seq_cst;
 
  template<class T>
    T kill_dependency(T y) noexcept;
 
  // lock-free property
  #define ATOMIC_BOOL_LOCK_FREE /* unspecified */
  #define ATOMIC_CHAR_LOCK_FREE /* unspecified */
  #define ATOMIC_CHAR8_T_LOCK_FREE /* unspecified */
  #define ATOMIC_CHAR16_T_LOCK_FREE /* unspecified */
  #define ATOMIC_CHAR32_T_LOCK_FREE /* unspecified */
  #define ATOMIC_WCHAR_T_LOCK_FREE /* unspecified */
  #define ATOMIC_SHORT_LOCK_FREE /* unspecified */
  #define ATOMIC_INT_LOCK_FREE /* unspecified */
  #define ATOMIC_LONG_LOCK_FREE /* unspecified */
  #define ATOMIC_LLONG_LOCK_FREE /* unspecified */
  #define ATOMIC_POINTER_LOCK_FREE /* unspecified */
 
  // class template atomic_ref
  template<class T> struct atomic_ref;
  // partial specialization for pointers
  template<class T> struct atomic_ref<T*>;
 
  // class template atomic
  template<class T> struct atomic;
  // partial specialization for pointers
  template<class T> struct atomic<T*>;
 
  // non-member functions
  template<class T>
    bool atomic_is_lock_free(const volatile atomic<T>*) noexcept;
  template<class T>
    bool atomic_is_lock_free(const atomic<T>*) noexcept;
  template<class T>
    void atomic_store(volatile atomic<T>*, typename atomic<T>::value_type) noexcept;
  template<class T>
    void atomic_store(atomic<T>*, typename atomic<T>::value_type) noexcept;
  template<class T>
    void atomic_store_explicit(volatile atomic<T>*, typename atomic<T>::value_type,
                               memory_order) noexcept;
  template<class T>
    void atomic_store_explicit(atomic<T>*, typename atomic<T>::value_type,
                               memory_order) noexcept;
  template<class T>
    T atomic_load(const volatile atomic<T>*) noexcept;
  template<class T>
    T atomic_load(const atomic<T>*) noexcept;
  template<class T>
    T atomic_load_explicit(const volatile atomic<T>*, memory_order) noexcept;
  template<class T>
    T atomic_load_explicit(const atomic<T>*, memory_order) noexcept;
  template<class T>
    T atomic_exchange(volatile atomic<T>*, typename atomic<T>::value_type) noexcept;
  template<class T>
    T atomic_exchange(atomic<T>*, typename atomic<T>::value_type) noexcept;
  template<class T>
    T atomic_exchange_explicit(volatile atomic<T>*, typename atomic<T>::value_type,
                               memory_order) noexcept;
  template<class T>
    T atomic_exchange_explicit(atomic<T>*, typename atomic<T>::value_type,
                               memory_order) noexcept;
  template<class T>
    bool atomic_compare_exchange_weak(volatile atomic<T>*,
                                      typename atomic<T>::value_type*,
                                      typename atomic<T>::value_type) noexcept;
  template<class T>
    bool atomic_compare_exchange_weak(atomic<T>*,
                                      typename atomic<T>::value_type*,
                                      typename atomic<T>::value_type) noexcept;
  template<class T>
    bool atomic_compare_exchange_strong(volatile atomic<T>*,
                                        typename atomic<T>::value_type*,
                                        typename atomic<T>::value_type) noexcept;
  template<class T>
    bool atomic_compare_exchange_strong(atomic<T>*,
                                        typename atomic<T>::value_type*,
                                        typename atomic<T>::value_type) noexcept;
  template<class T>
    bool atomic_compare_exchange_weak_explicit(volatile atomic<T>*,
                                               typename atomic<T>::value_type*,
                                               typename atomic<T>::value_type,
                                               memory_order, memory_order) noexcept;
  template<class T>
    bool atomic_compare_exchange_weak_explicit(atomic<T>*,
                                               typename atomic<T>::value_type*,
                                               typename atomic<T>::value_type,
                                               memory_order, memory_order) noexcept;
  template<class T>
    bool atomic_compare_exchange_strong_explicit(volatile atomic<T>*,
                                                 typename atomic<T>::value_type*,
                                                 typename atomic<T>::value_type,
                                                 memory_order, memory_order) noexcept;
  template<class T>
    bool atomic_compare_exchange_strong_explicit(atomic<T>*,
                                                 typename atomic<T>::value_type*,
                                                 typename atomic<T>::value_type,
                                                 memory_order, memory_order) noexcept;
 
  template<class T>
    T atomic_fetch_add(volatile atomic<T>*, typename atomic<T>::difference_type) noexcept;
  template<class T>
    T atomic_fetch_add(atomic<T>*, typename atomic<T>::difference_type) noexcept;
  template<class T>
    T atomic_fetch_add_explicit(volatile atomic<T>*, typename atomic<T>::difference_type,
                                memory_order) noexcept;
  template<class T>
    T atomic_fetch_add_explicit(atomic<T>*, typename atomic<T>::difference_type,
                                memory_order) noexcept;
  template<class T>
    T atomic_fetch_sub(volatile atomic<T>*, typename atomic<T>::difference_type) noexcept;
  template<class T>
    T atomic_fetch_sub(atomic<T>*, typename atomic<T>::difference_type) noexcept;
  template<class T>
    T atomic_fetch_sub_explicit(volatile atomic<T>*, typename atomic<T>::difference_type,
                                memory_order) noexcept;
  template<class T>
    T atomic_fetch_sub_explicit(atomic<T>*, typename atomic<T>::difference_type,
                                memory_order) noexcept;
  template<class T>
    T atomic_fetch_and(volatile atomic<T>*, typename atomic<T>::value_type) noexcept;
  template<class T>
    T atomic_fetch_and(atomic<T>*, typename atomic<T>::value_type) noexcept;
  template<class T>
    T atomic_fetch_and_explicit(volatile atomic<T>*, typename atomic<T>::value_type,
                                memory_order) noexcept;
  template<class T>
    T atomic_fetch_and_explicit(atomic<T>*, typename atomic<T>::value_type,
                                memory_order) noexcept;
  template<class T>
    T atomic_fetch_or(volatile atomic<T>*, typename atomic<T>::value_type) noexcept;
  template<class T>
    T atomic_fetch_or(atomic<T>*, typename atomic<T>::value_type) noexcept;
  template<class T>
    T atomic_fetch_or_explicit(volatile atomic<T>*, typename atomic<T>::value_type,
                               memory_order) noexcept;
  template<class T>
    T atomic_fetch_or_explicit(atomic<T>*, typename atomic<T>::value_type,
                               memory_order) noexcept;
  template<class T>
    T atomic_fetch_xor(volatile atomic<T>*, typename atomic<T>::value_type) noexcept;
  template<class T>
    T atomic_fetch_xor(atomic<T>*, typename atomic<T>::value_type) noexcept;
  template<class T>
    T atomic_fetch_xor_explicit(volatile atomic<T>*, typename atomic<T>::value_type,
                                memory_order) noexcept;
  template<class T>
    T atomic_fetch_xor_explicit(atomic<T>*, typename atomic<T>::value_type,
                                memory_order) noexcept;
 
  template<class T>
    void atomic_wait(const volatile atomic<T>*, typename atomic<T>::value_type);
  template<class T>
    void atomic_wait(const atomic<T>*, typename atomic<T>::value_type);
  template<class T>
    void atomic_wait_explicit(const volatile atomic<T>*, typename atomic<T>::value_type,
                              memory_order);
  template<class T>
    void atomic_wait_explicit(const atomic<T>*, typename atomic<T>::value_type,
                              memory_order);
  template<class T>
    void atomic_notify_one(volatile atomic<T>*);
  template<class T>
    void atomic_notify_one(atomic<T>*);
  template<class T>
    void atomic_notify_all(volatile atomic<T>*);
  template<class T>
    void atomic_notify_all(atomic<T>*);
 
  // type aliases
  using atomic_bool           = atomic<bool>;
  using atomic_char           = atomic<char>;
  using atomic_schar          = atomic<signed char>;
  using atomic_uchar          = atomic<unsigned char>;
  using atomic_short          = atomic<short>;
  using atomic_ushort         = atomic<unsigned short>;
  using atomic_int            = atomic<int>;
  using atomic_uint           = atomic<unsigned int>;
  using atomic_long           = atomic<long>;
  using atomic_ulong          = atomic<unsigned long>;
  using atomic_llong          = atomic<long long>;
  using atomic_ullong         = atomic<unsigned long long>;
  using atomic_char8_t        = atomic<char8_t>;
  using atomic_char16_t       = atomic<char16_t>;
  using atomic_char32_t       = atomic<char32_t>;
  using atomic_wchar_t        = atomic<wchar_t>;
 
  using atomic_int8_t         = atomic<int8_t>;
  using atomic_uint8_t        = atomic<uint8_t>;
  using atomic_int16_t        = atomic<int16_t>;
  using atomic_uint16_t       = atomic<uint16_t>;
  using atomic_int32_t        = atomic<int32_t>;
  using atomic_uint32_t       = atomic<uint32_t>;
  using atomic_int64_t        = atomic<int64_t>;
  using atomic_uint64_t       = atomic<uint64_t>;
 
  using atomic_int_least8_t   = atomic<int_least8_t>;
  using atomic_uint_least8_t  = atomic<uint_least8_t>;
  using atomic_int_least16_t  = atomic<int_least16_t>;
  using atomic_uint_least16_t = atomic<uint_least16_t>;
  using atomic_int_least32_t  = atomic<int_least32_t>;
  using atomic_uint_least32_t = atomic<uint_least32_t>;
  using atomic_int_least64_t  = atomic<int_least64_t>;
  using atomic_uint_least64_t = atomic<uint_least64_t>;
 
  using atomic_int_fast8_t    = atomic<int_fast8_t>;
  using atomic_uint_fast8_t   = atomic<uint_fast8_t>;
  using atomic_int_fast16_t   = atomic<int_fast16_t>;
  using atomic_uint_fast16_t  = atomic<uint_fast16_t>;
  using atomic_int_fast32_t   = atomic<int_fast32_t>;
  using atomic_uint_fast32_t  = atomic<uint_fast32_t>;
  using atomic_int_fast64_t   = atomic<int_fast64_t>;
  using atomic_uint_fast64_t  = atomic<uint_fast64_t>;
 
  using atomic_intptr_t       = atomic<intptr_t>;
  using atomic_uintptr_t      = atomic<uintptr_t>;
  using atomic_size_t         = atomic<size_t>;
  using atomic_ptrdiff_t      = atomic<ptrdiff_t>;
  using atomic_intmax_t       = atomic<intmax_t>;
  using atomic_uintmax_t      = atomic<uintmax_t>;
 
  using atomic_signed_lock_free   = /* see description */;
  using atomic_unsigned_lock_free = /* see description */;
 
  // flag type and operations
  struct atomic_flag;
 
  bool atomic_flag_test(const volatile atomic_flag*) noexcept;
  bool atomic_flag_test(const atomic_flag*) noexcept;
  bool atomic_flag_test_explicit(const volatile atomic_flag*, memory_order) noexcept;
  bool atomic_flag_test_explicit(const atomic_flag*, memory_order) noexcept;
  bool atomic_flag_test_and_set(volatile atomic_flag*) noexcept;
  bool atomic_flag_test_and_set(atomic_flag*) noexcept;
  bool atomic_flag_test_and_set_explicit(volatile atomic_flag*, memory_order) noexcept;
  bool atomic_flag_test_and_set_explicit(atomic_flag*, memory_order) noexcept;
  void atomic_flag_clear(volatile atomic_flag*) noexcept;
  void atomic_flag_clear(atomic_flag*) noexcept;
  void atomic_flag_clear_explicit(volatile atomic_flag*, memory_order) noexcept;
  void atomic_flag_clear_explicit(atomic_flag*, memory_order) noexcept;
 
  void atomic_flag_wait(const volatile atomic_flag*, bool) noexcept;
  void atomic_flag_wait(const atomic_flag*, bool) noexcept;
  void atomic_flag_wait_explicit(const volatile atomic_flag*,
                                 bool, memory_order) noexcept;
  void atomic_flag_wait_explicit(const atomic_flag*,
                                 bool, memory_order) noexcept;
  void atomic_flag_notify_one(volatile atomic_flag*) noexcept;
  void atomic_flag_notify_one(atomic_flag*) noexcept;
  void atomic_flag_notify_all(volatile atomic_flag*) noexcept;
  void atomic_flag_notify_all(atomic_flag*) noexcept;
 
  // fences
  extern "C" void atomic_thread_fence(memory_order) noexcept;
  extern "C" void atomic_signal_fence(memory_order) noexcept;
}
// deprecated
namespace std {
  template<class T>
    void atomic_init(volatile atomic<T>*, typename atomic<T>::value_type) noexcept;
  template<class T>
    void atomic_init(atomic<T>*, typename atomic<T>::value_type) noexcept;
 
  #define ATOMIC_VAR_INIT(value) /* see description */
 
  #define ATOMIC_FLAG_INIT /* see description */
}

namespace std {
  template<class T> struct atomic {
    using value_type = T;
 
    static constexpr bool is_always_lock_free = /* implementation-defined */;
    bool is_lock_free() const volatile noexcept;
    bool is_lock_free() const noexcept;
 
    // operations on atomic types
    constexpr atomic() noexcept(is_nothrow_default_constructible_v<T>);
    constexpr atomic(T) noexcept;
    atomic(const atomic&) = delete;
    atomic& operator=(const atomic&) = delete;
    atomic& operator=(const atomic&) volatile = delete;
 
    T load(memory_order = memory_order::seq_cst) const volatile noexcept;
    T load(memory_order = memory_order::seq_cst) const noexcept;
    operator T() const volatile noexcept;
    operator T() const noexcept;
    void store(T, memory_order = memory_order::seq_cst) volatile noexcept;
    void store(T, memory_order = memory_order::seq_cst) noexcept;
    T operator=(T) volatile noexcept;
    T operator=(T) noexcept;
 
    T exchange(T, memory_order = memory_order::seq_cst) volatile noexcept;
    T exchange(T, memory_order = memory_order::seq_cst) noexcept;
    bool compare_exchange_weak(T&, T, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_weak(T&, T, memory_order, memory_order) noexcept;
    bool compare_exchange_strong(T&, T, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_strong(T&, T, memory_order, memory_order) noexcept;
    bool compare_exchange_weak(T&, T,
                               memory_order = memory_order::seq_cst) volatile noexcept;
    bool compare_exchange_weak(T&, T, memory_order = memory_order::seq_cst) noexcept;
    bool compare_exchange_strong(T&, T,
                                 memory_order = memory_order::seq_cst) volatile noexcept;
    bool compare_exchange_strong(T&, T, memory_order = memory_order::seq_cst) noexcept;
 
    void wait(T, memory_order = memory_order::seq_cst) const volatile noexcept;
    void wait(T, memory_order = memory_order::seq_cst) const noexcept;
    void notify_one() volatile noexcept;
    void notify_one() noexcept;
    void notify_all() volatile noexcept;
    void notify_all() noexcept;
  };
}

namespace std {
  template<> struct atomic<int> {
    using value_type = int;
    using difference_type = value_type;
 
    static constexpr bool is_always_lock_free = /* implementation-defined */;
    bool is_lock_free() const volatile noexcept;
    bool is_lock_free() const noexcept;
 
    constexpr atomic() noexcept;
    constexpr atomic(int) noexcept;
    atomic(const atomic&) = delete;
    atomic& operator=(const atomic&) = delete;
    atomic& operator=(const atomic&) volatile = delete;
 
    void store(int, memory_order = memory_order::seq_cst) volatile noexcept;
    void store(int, memory_order = memory_order::seq_cst) noexcept;
    int operator=(int) volatile noexcept;
    int operator=(int) noexcept;
    int load(memory_order = memory_order::seq_cst) const volatile noexcept;
    int load(memory_order = memory_order::seq_cst) const noexcept;
    operator int() const volatile noexcept;
    operator int() const noexcept;
 
    int exchange(int, memory_order = memory_order::seq_cst) volatile noexcept;
    int exchange(int, memory_order = memory_order::seq_cst) noexcept;
    bool compare_exchange_weak(int&, int,
                               memory_order, memory_order) volatile noexcept;
    bool compare_exchange_weak(int&, int,
                               memory_order, memory_order) noexcept;
    bool compare_exchange_strong(int&, int,
                                 memory_order, memory_order) volatile noexcept;
    bool compare_exchange_strong(int&, int,
                                 memory_order, memory_order) noexcept;
    bool compare_exchange_weak(int&, int,
                               memory_order = memory_order::seq_cst) volatile noexcept;
    bool compare_exchange_weak(int&, int,
                               memory_order = memory_order::seq_cst) noexcept;
    bool compare_exchange_strong(int&, int,
                                 memory_order = memory_order::seq_cst) volatile noexcept;
    bool compare_exchange_strong(int&, int,
                                 memory_order = memory_order::seq_cst) noexcept;
 
    int fetch_add(int,
                         memory_order = memory_order::seq_cst) volatile noexcept;
    int fetch_add(int,
                         memory_order = memory_order::seq_cst) noexcept;
    int fetch_sub(int,
                         memory_order = memory_order::seq_cst) volatile noexcept;
    int fetch_sub(int,
                         memory_order = memory_order::seq_cst) noexcept;
    int fetch_and(int,
                         memory_order = memory_order::seq_cst) volatile noexcept;
    int fetch_and(int,
                         memory_order = memory_order::seq_cst) noexcept;
    int fetch_or(int,
                         memory_order = memory_order::seq_cst) volatile noexcept;
    int fetch_or(int,
                         memory_order = memory_order::seq_cst) noexcept;
    int fetch_xor(int,
                         memory_order = memory_order::seq_cst) volatile noexcept;
    int fetch_xor(int,
                         memory_order = memory_order::seq_cst) noexcept;
 
    int operator++(int) volatile noexcept;
    int operator++(int) noexcept;
    int operator--(int) volatile noexcept;
    int operator--(int) noexcept;
    int operator++() volatile noexcept;
    int operator++() noexcept;
    int operator--() volatile noexcept;
    int operator--() noexcept;
    int operator+=(int) volatile noexcept;
    int operator+=(int) noexcept;
    int operator-=(int) volatile noexcept;
    int operator-=(int) noexcept;
    int operator&=(int) volatile noexcept;
    int operator&=(int) noexcept;
    int operator|=(int) volatile noexcept;
    int operator|=(int) noexcept;
    int operator^=(int) volatile noexcept;
    int operator^=(int) noexcept;
 
    void wait(int,memory_order = memory_order::seq_cst) const volatile noexcept;
    void wait(int, memory_order = memory_order::seq_cst) const noexcept;
    void notify_one() volatile noexcept;
    void notify_one() noexcept;
    void notify_all() volatile noexcept;
    void notify_all() noexcept;
  };
}

namespace std {
  template<class T> struct atomic<T*> {
    using value_type = T*;
    using difference_type = ptrdiff_t;
 
    static constexpr bool is_always_lock_free = /* implementation-defined */;
    bool is_lock_free() const volatile noexcept;
    bool is_lock_free() const noexcept;
 
    constexpr atomic() noexcept;
    constexpr atomic(T*) noexcept;
    atomic(const atomic&) = delete;
    atomic& operator=(const atomic&) = delete;
    atomic& operator=(const atomic&) volatile = delete;
 
    void store(T*, memory_order = memory_order::seq_cst) volatile noexcept;
    void store(T*, memory_order = memory_order::seq_cst) noexcept;
    T* operator=(T*) volatile noexcept;
    T* operator=(T*) noexcept;
    T* load(memory_order = memory_order::seq_cst) const volatile noexcept;
    T* load(memory_order = memory_order::seq_cst) const noexcept;
    operator T*() const volatile noexcept;
    operator T*() const noexcept;
 
    T* exchange(T*, memory_order = memory_order::seq_cst) volatile noexcept;
    T* exchange(T*, memory_order = memory_order::seq_cst) noexcept;
    bool compare_exchange_weak(T*&, T*, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_weak(T*&, T*, memory_order, memory_order) noexcept;
    bool compare_exchange_strong(T*&, T*, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_strong(T*&, T*, memory_order, memory_order) noexcept;
    bool compare_exchange_weak(T*&, T*,
                               memory_order = memory_order::seq_cst) volatile noexcept;
    bool compare_exchange_weak(T*&, T*,
                               memory_order = memory_order::seq_cst) noexcept;
    bool compare_exchange_strong(T*&, T*,
                                 memory_order = memory_order::seq_cst) volatile noexcept;
    bool compare_exchange_strong(T*&, T*,
                                 memory_order = memory_order::seq_cst) noexcept;
 
    T* fetch_add(ptrdiff_t, memory_order = memory_order::seq_cst) volatile noexcept;
    T* fetch_add(ptrdiff_t, memory_order = memory_order::seq_cst) noexcept;
    T* fetch_sub(ptrdiff_t, memory_order = memory_order::seq_cst) volatile noexcept;
    T* fetch_sub(ptrdiff_t, memory_order = memory_order::seq_cst) noexcept;
 
    T* operator++(int) volatile noexcept;
    T* operator++(int) noexcept;
    T* operator--(int) volatile noexcept;
    T* operator--(int) noexcept;
    T* operator++() volatile noexcept;
    T* operator++() noexcept;
    T* operator--() volatile noexcept;
    T* operator--() noexcept;
    T* operator+=(ptrdiff_t) volatile noexcept;
    T* operator+=(ptrdiff_t) noexcept;
    T* operator-=(ptrdiff_t) volatile noexcept;
    T* operator-=(ptrdiff_t) noexcept;
 
    void wait(T*, memory_order = memory_order::seq_cst) const volatile noexcept;
    void wait(T*, memory_order = memory_order::seq_cst) const noexcept;
    void notify_one() volatile noexcept;
    void notify_one() noexcept;
    void notify_all() volatile noexcept;
    void notify_all() noexcept;
  };
}

namespace std {
  template<class T> struct atomic_ref {
  private:
    T* ptr;             // exposition only
  public:
    using value_type = T;
    static constexpr size_t required_alignment = /* implementation-defined */;
 
    static constexpr bool is_always_lock_free = /* implementation-defined */;
    bool is_lock_free() const noexcept;
 
    explicit atomic_ref(T&);
    atomic_ref(const atomic_ref&) noexcept;
    atomic_ref& operator=(const atomic_ref&) = delete;
 
    void store(T, memory_order = memory_order_seq_cst) const noexcept;
    T operator=(T) const noexcept;
    T load(memory_order = memory_order_seq_cst) const noexcept;
    operator T() const noexcept;
 
    T exchange(T, memory_order = memory_order_seq_cst) const noexcept;
    bool compare_exchange_weak(T&, T,
                               memory_order, memory_order) const noexcept;
    bool compare_exchange_strong(T&, T,
                                 memory_order, memory_order) const noexcept;
    bool compare_exchange_weak(T&, T,
                               memory_order = memory_order_seq_cst) const noexcept;
    bool compare_exchange_strong(T&, T,
                                 memory_order = memory_order_seq_cst) const noexcept;
 
    void wait(T, memory_order = memory_order::seq_cst) const noexcept;
    void notify_one() const noexcept;
    void notify_all() const noexcept;
  };
}

namespace std {
  template<> struct atomic_ref</* integral */> {
  private:
    /* integral */* ptr;        // exposition only
  public:
    using value_type = /* integral */;
    using difference_type = value_type;
    static constexpr size_t required_alignment = /* implementation-defined */;
 
    static constexpr bool is_always_lock_free = /* implementation-defined */;
    bool is_lock_free() const noexcept;
 
    explicit atomic_ref(/* integral */&);
    atomic_ref(const atomic_ref&) noexcept;
    atomic_ref& operator=(const atomic_ref&) = delete;
 
    void store(/* integral */, memory_order = memory_order_seq_cst) const noexcept;
    /* integral */ operator=(/* integral */) const noexcept;
    /* integral */ load(memory_order = memory_order_seq_cst) const noexcept;
    operator /* integral */() const noexcept;
 
    /* integral */ exchange(/* integral */,
                      memory_order = memory_order_seq_cst) const noexcept;
    bool compare_exchange_weak(/* integral */&, /* integral */,
                               memory_order, memory_order) const noexcept;
    bool compare_exchange_strong(/* integral */&, /* integral */,
                                 memory_order, memory_order) const noexcept;
    bool compare_exchange_weak(/* integral */&, /* integral */,
                               memory_order = memory_order_seq_cst) const noexcept;
    bool compare_exchange_strong(/* integral */&, /* integral */,
                                 memory_order = memory_order_seq_cst) const noexcept;
 
    /* integral */ fetch_add(/* integral */,
                       memory_order = memory_order_seq_cst) const noexcept;
    /* integral */ fetch_sub(/* integral */,
                       memory_order = memory_order_seq_cst) const noexcept;
    /* integral */ fetch_and(/* integral */,
                       memory_order = memory_order_seq_cst) const noexcept;
    /* integral */ fetch_or(/* integral */,
                      memory_order = memory_order_seq_cst) const noexcept;
    /* integral */ fetch_xor(/* integral */,
                       memory_order = memory_order_seq_cst) const noexcept;
 
    /* integral */ operator++(int) const noexcept;
    /* integral */ operator--(int) const noexcept;
    /* integral */ operator++() const noexcept;
    /* integral */ operator--() const noexcept;
    /* integral */ operator+=(/* integral */) const noexcept;
    /* integral */ operator-=(/* integral */) const noexcept;
    /* integral */ operator&=(/* integral */) const noexcept;
  };
}

namespace std {
  template<> struct atomic_ref<float> {
  private:
    float* ptr;  // exposition only
  public:
    using value_type = float;
    using difference_type = value_type;
    static constexpr size_t required_alignment = /* implementation-defined */;
 
    static constexpr bool is_always_lock_free = /* implementation-defined */;
    bool is_lock_free() const noexcept;
 
    explicit atomic_ref(float&);
    atomic_ref(const atomic_ref&) noexcept;
    atomic_ref& operator=(const atomic_ref&) = delete;
 
    void store(float, memory_order = memory_order_seq_cst) const noexcept;
    float operator=(float) const noexcept;
    float load(memory_order = memory_order_seq_cst) const noexcept;
    operator float() const noexcept;
 
    float exchange(float,
                            memory_order = memory_order_seq_cst) const noexcept;
    bool compare_exchange_weak(float&, float,
                               memory_order, memory_order) const noexcept;
    bool compare_exchange_strong(float&, float,
                                 memory_order, memory_order) const noexcept;
    bool compare_exchange_weak(float&, float,
                               memory_order = memory_order_seq_cst) const noexcept;
    bool compare_exchange_strong(float&, float,
                                 memory_order = memory_order_seq_cst) const noexcept;
 
    float fetch_add(float,memory_order = memory_order_seq_cst) const noexcept;
    float fetch_sub(float,memory_order = memory_order_seq_cst) const noexcept;
 
    float operator+=(float) const noexcept;
    float operator-=(float) const noexcept;
 
    void wait(float, memory_order = memory_order::seq_cst) const noexcept;
    void notify_one() const noexcept;
    void notify_all() const noexcept;
  };
}

namespace std {
  template<> struct atomic_ref<double> {
  private:
    double* ptr;  // exposition only
  public:
    using value_type = double;
    using difference_type = value_type;
    static constexpr size_t required_alignment = /* implementation-defined */;
 
    static constexpr bool is_always_lock_free = /* implementation-defined */;
    bool is_lock_free() const noexcept;
 
    explicit atomic_ref(double&);
    atomic_ref(const atomic_ref&) noexcept;
    atomic_ref& operator=(const atomic_ref&) = delete;
 
    void store(double, memory_order = memory_order_seq_cst) const noexcept;
    double operator=(double) const noexcept;
    double load(memory_order = memory_order_seq_cst) const noexcept;
    operator double() const noexcept;
 
    double exchange(double,memory_order = memory_order_seq_cst) const noexcept;
    bool compare_exchange_weak(double&, double,memory_order, memory_order) const noexcept;
    bool compare_exchange_strong(double&, double,memory_order, memory_order) const noexcept;
    bool compare_exchange_weak(double&, double,memory_order = memory_order_seq_cst) const noexcept;
    bool compare_exchange_strong(double&, double,memory_order = memory_order_seq_cst) const noexcept;
 
    double fetch_add(double,memory_order = memory_order_seq_cst) const noexcept;
    double fetch_sub(double,memory_order = memory_order_seq_cst) const noexcept;
 
    double operator+=(double) const noexcept;
    double operator-=(double) const noexcept;
 
    void wait(double, memory_order = memory_order::seq_cst) const noexcept;
    void notify_one() const noexcept;
    void notify_all() const noexcept;
  };
}

namespace std {
  template<class T> struct atomic_ref<T*> {
  private:
    T** ptr;        // exposition only
  public:
    using value_type = T*;
    using difference_type = ptrdiff_t;
    static constexpr size_t required_alignment = /* implementation-defined */;
 
    static constexpr bool is_always_lock_free = /* implementation-defined */;
    bool is_lock_free() const noexcept;
 
    explicit atomic_ref(T*&);
    atomic_ref(const atomic_ref&) noexcept;
    atomic_ref& operator=(const atomic_ref&) = delete;
 
    void store(T*, memory_order = memory_order_seq_cst) const noexcept;
    T* operator=(T*) const noexcept;
    T* load(memory_order = memory_order_seq_cst) const noexcept;
    operator T*() const noexcept;
 
    T* exchange(T*, memory_order = memory_order_seq_cst) const noexcept;
    bool compare_exchange_weak(T*&, T*,
                               memory_order, memory_order) const noexcept;
    bool compare_exchange_strong(T*&, T*,
                                 memory_order, memory_order) const noexcept;
    bool compare_exchange_weak(T*&, T*,
                               memory_order = memory_order_seq_cst) const noexcept;
    bool compare_exchange_strong(T*&, T*,
                                 memory_order = memory_order_seq_cst) const noexcept;
 
    T* fetch_add(difference_type, memory_order = memory_order_seq_cst) const noexcept;
    T* fetch_sub(difference_type, memory_order = memory_order_seq_cst) const noexcept;
 
    T* operator++(int) const noexcept;
    T* operator--(int) const noexcept;
    T* operator++() const noexcept;
    T* operator--() const noexcept;
    T* operator+=(difference_type) const noexcept;
    T* operator-=(difference_type) const noexcept;
 
    void wait(T*, memory_order = memory_order::seq_cst) const noexcept;
    void notify_one() const noexcept;
    void notify_all() const noexcept;
  };
}

namespace std {
  struct atomic_flag {
    constexpr atomic_flag() noexcept;
    atomic_flag(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) volatile = delete;
 
    bool test(memory_order = memory_order::seq_cst) const volatile noexcept;
    bool test(memory_order = memory_order::seq_cst) const noexcept;
    bool test_and_set(memory_order = memory_order::seq_cst) volatile noexcept;
    bool test_and_set(memory_order = memory_order::seq_cst) noexcept;
    void clear(memory_order = memory_order::seq_cst) volatile noexcept;
    void clear(memory_order = memory_order::seq_cst) noexcept;
 
    void wait(bool, memory_order = memory_order::seq_cst) const volatile noexcept;
    void wait(bool, memory_order = memory_order::seq_cst) const noexcept;
    void notify_one() volatile noexcept;
    void notify_one() noexcept;
    void notify_all() volatile noexcept;
    void notify_all() noexcept;
  };
}
