/*******************************************************************************
 * Copyright (c) 2022, Jan Koester jan.koester@gmx.net
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 * Neither the name of the <organization> nor the
 *      names of its contributors may be used to endorse or promote products
 *      derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *******************************************************************************/

#include "iosfwd"

#pragma once

namespace std {
  using streamoff  = long long;
  using streamsize = std::size_t;
  template<class StateT> class fpos;
 
  class ios_base;
  template<class CharT, class Traits = char_traits<CharT>>
    class basic_ios;
 
  // manipulators
  ios_base& boolalpha  (ios_base& str);
  ios_base& noboolalpha(ios_base& str);
 
  ios_base& showbase   (ios_base& str);
  ios_base& noshowbase (ios_base& str);
 
  ios_base& showpoint  (ios_base& str);
  ios_base& noshowpoint(ios_base& str);
 
  ios_base& showpos    (ios_base& str);
  ios_base& noshowpos  (ios_base& str);
 
  ios_base& skipws     (ios_base& str);
  ios_base& noskipws   (ios_base& str);
 
  ios_base& uppercase  (ios_base& str);
  ios_base& nouppercase(ios_base& str);
 
  ios_base& unitbuf    (ios_base& str);
  ios_base& nounitbuf  (ios_base& str);
 
  // adjustfield
  ios_base& internal   (ios_base& str);
  ios_base& left       (ios_base& str);
  ios_base& right      (ios_base& str);
 
  // basefield
  ios_base& dec        (ios_base& str);
  ios_base& hex        (ios_base& str);
  ios_base& oct        (ios_base& str);
 
  // floatfield
  ios_base& fixed      (ios_base& str);
  ios_base& scientific (ios_base& str);
  ios_base& hexfloat   (ios_base& str);
  ios_base& defaultfloat(ios_base& str);
 
  // error reporting
  enum class io_errc {
    stream = 1
  };
 
  template<> struct is_error_code_enum<io_errc> : public true_type { };
  error_code make_error_code(io_errc e) noexcept;
  error_condition make_error_condition(io_errc e) noexcept;
  const error_category& iostream_category() noexcept;
}

namespace std {
  class ios_base {
  public:
    class failure;              // see description
 
    typedef unsigned int fmtflags;
    static const fmtflags boolalpha   = 0x0001;
    static const fmtflags dec         = 0x0002;
    static const fmtflags fixed       = 0x0004;
    static const fmtflags hex         = 0x0008;
    static const fmtflags internal    = 0x0010;
    static const fmtflags left        = 0x0020;
    static const fmtflags oct         = 0x0040;
    static const fmtflags right       = 0x0080;
    static const fmtflags scientific  = 0x0100;
    static const fmtflags showbase    = 0x0200;
    static const fmtflags showpoint   = 0x0400;
    static const fmtflags showpos     = 0x0800;
    static const fmtflags skipws      = 0x1000;
    static const fmtflags unitbuf     = 0x2000;
    static const fmtflags uppercase   = 0x4000;
    static const fmtflags adjustfield = left | right | internal;
    static const fmtflags basefield   = dec | oct | hex;
    static const fmtflags floatfield  = scientific | fixed;

    typedef unsigned int iostate;
    static const iostate badbit  = 0x1;
    static const iostate eofbit  = 0x2;
    static const iostate failbit = 0x4;
    static const iostate goodbit = 0x0;

    typedef unsigned int openmode;
    static const openmode app    = 0x01;
    static const openmode ate    = 0x02;
    static const openmode binary = 0x04;
    static const openmode in     = 0x08;
    static const openmode out    = 0x10;
    static const openmode trunc  = 0x20;
 
    // seekdir
    enum seekdir {beg, cur, end};
    
    typedef iostate      io_state;
    typedef openmode     open_mode;
    typedef seekdir      seek_dir;
 
    class Init;
 
    // fmtflags state
    fmtflags flags() const;
    fmtflags flags(fmtflags fmtfl);
    fmtflags setf(fmtflags fmtfl);
    fmtflags setf(fmtflags fmtfl, fmtflags mask);
    void unsetf(fmtflags mask);
 
    streamsize precision() const;
    streamsize precision(streamsize prec);
    streamsize width() const;
    streamsize width(streamsize wide);
 
    // locales
    locale imbue(const locale& loc);
    locale getloc() const;
 
    // storage
    static int xalloc();
    long&  iword(int idx);
    void*& pword(int idx);
 
    // destructor
    virtual ~ios_base();
 
    // callbacks
    enum event { erase_event, imbue_event, copyfmt_event };
    using event_callback = void (*)(event, ios_base&, int idx);
    void register_callback(event_callback fn, int idx);
 
    ios_base(const ios_base&) = delete;
    ios_base& operator=(const ios_base&) = delete;
 
    static bool sync_with_stdio(bool sync = true);
 
  protected:
    ios_base();
 
  private:
    static int index;           // exposition only
    long*  iarray;              // exposition only
    void** parray;              // exposition only
  };
}

namespace std {
  class ios_base {
  public:
    class failure;              // see description
 
    // fmtflags
    using fmtflags = /*bitmask-type-1*/;
    static constexpr fmtflags boolalpha = /* unspecified */;
    static constexpr fmtflags dec = /* unspecified */;
    static constexpr fmtflags fixed = /* unspecified */;
    static constexpr fmtflags hex = /* unspecified */;
    static constexpr fmtflags internal = /* unspecified */;
    static constexpr fmtflags left = /* unspecified */;
    static constexpr fmtflags oct = /* unspecified */;
    static constexpr fmtflags right = /* unspecified */;
    static constexpr fmtflags scientific = /* unspecified */;
    static constexpr fmtflags showbase = /* unspecified */;
    static constexpr fmtflags showpoint = /* unspecified */;
    static constexpr fmtflags showpos = /* unspecified */;
    static constexpr fmtflags skipws = /* unspecified */;
    static constexpr fmtflags unitbuf = /* unspecified */;
    static constexpr fmtflags uppercase = /* unspecified */;
    static constexpr fmtflags adjustfield = /* see description */;
    static constexpr fmtflags basefield = /* see description */;
    static constexpr fmtflags floatfield = /* see description */;
 
    // iostate
    using iostate = /*bitmask-type-2*/;
    static constexpr iostate badbit = /* unspecified */;
    static constexpr iostate eofbit = /* unspecified */;
    static constexpr iostate failbit = /* unspecified */;
    static constexpr iostate goodbit = /* see description */;
 
    // openmode
    using openmode = /*bitmask-type-3*/;
    static constexpr openmode app = /* unspecified */;
    static constexpr openmode ate = /* unspecified */;
    static constexpr openmode binary = /* unspecified */;
    static constexpr openmode in = /* unspecified */;
    static constexpr openmode out = /* unspecified */;
    static constexpr openmode trunc = /* unspecified */;
 
    // seekdir
    using seekdir = /*bitmask-type-4*/;
    static constexpr seekdir beg = /* unspecified */;
    static constexpr seekdir cur = /* unspecified */;
    static constexpr seekdir end = /* unspecified */;
 
    class Init;
 
    // fmtflags state
    fmtflags flags() const;
    fmtflags flags(fmtflags fmtfl);
    fmtflags setf(fmtflags fmtfl);
    fmtflags setf(fmtflags fmtfl, fmtflags mask);
    void unsetf(fmtflags mask);
 
    streamsize precision() const;
    streamsize precision(streamsize prec);
    streamsize width() const;
    streamsize width(streamsize wide);
 
    // locales
    locale imbue(const locale& loc);
    locale getloc() const;
 
    // storage
    static int xalloc();
    long&  iword(int idx);
    void*& pword(int idx);
 
    // destructor
    virtual ~ios_base();
 
    // callbacks
    enum event { erase_event, imbue_event, copyfmt_event };
    using event_callback = void (*)(event, ios_base&, int idx);
    void register_callback(event_callback fn, int idx);
 
    ios_base(const ios_base&) = delete;
    ios_base& operator=(const ios_base&) = delete;
 
    static bool sync_with_stdio(bool sync = true);
 
  protected:
    ios_base();
 
  private:
    static int index;           // exposition only
    long*  iarray;              // exposition only
    void** parray;              // exposition only
  };
}

namespace std {
  class ios_base::failure : public system_error {
  public:
    explicit failure(const string& msg, const error_code& ec = io_errc::stream);
    explicit failure(const char* msg, const error_code& ec = io_errc::stream);
  };
}

namespace std {
  class ios_base::Init {
  public:
    Init();
    Init(const Init&) = default;
    ~Init();
    Init& operator=(const Init&) = default;
  private:
    static int init_cnt;        // exposition only
  };
}

namespace std {
  template<class StateT> class fpos {
  public:
    // members
    StateT state() const;
    void state(stateT);
  private;
    StateT st;                  // exposition only
  };
}

namespace std {
  template<class CharT, class Traits = char_traits<CharT>>
  class basic_ios : public ios_base {
  public:
    using char_type   = CharT;
    using int_type    = typename Traits::int_type;
    using pos_type    = typename Traits::pos_type;
    using off_type    = typename Traits::off_type;
    using traits_type = Traits;
 
    // flags functions
    explicit operator bool() const;
    bool operator!() const;
    iostate rdstate() const;
    void clear(iostate state = goodbit);
    void setstate(iostate state);
    bool good() const;
    bool eof()  const;
    bool fail() const;
    bool bad()  const;
 
    iostate exceptions() const;
    void exceptions(iostate except);
 
    // constructor/destructor
    explicit basic_ios(basic_streambuf<CharT, Traits>* sb);
    virtual ~basic_ios();
 
    // members
    basic_ostream<CharT, Traits>* tie() const;
    basic_ostream<CharT, Traits>* tie(basic_ostream<CharT, Traits>* tiestr);
 
    basic_streambuf<CharT, Traits>* rdbuf() const;
    basic_streambuf<CharT, Traits>* rdbuf(basic_streambuf<CharT, Traits>* sb);
 
    basic_ios& copyfmt(const basic_ios& rhs);
 
    char_type fill() const;
    char_type fill(char_type ch);
 
    locale imbue(const locale& loc);
 
    char      narrow(char_type c, char dfault) const;
    char_type widen(char c) const;
 
    basic_ios(const basic_ios&) = delete;
    basic_ios& operator=(const basic_ios&) = delete;
 
  protected:
    basic_ios();
    void init(basic_streambuf<CharT, Traits>* sb);
    void move(basic_ios& rhs);
    void move(basic_ios&& rhs);
    void swap(basic_ios& rhs) noexcept;
    void set_rdbuf(basic_streambuf<CharT, Traits>* sb);
 
  };
}
